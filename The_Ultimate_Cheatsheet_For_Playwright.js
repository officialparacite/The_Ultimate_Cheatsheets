/* Prerequisites */
// Get the LTS version of latest Node runtime


/* Install playwright */
// Create a new folder and cd into it then `npm init playwright@latest` to get the latest playwright package (accept the defaults)


/* Project structure explanation */
// The node modules package has the binaries required for the project
// The tests folder consists of all the test files that will be run during execution
// tests-examples folder will not be used in the test runner it just has more examples of playwright can do
// package.json is the file that describes the overall project
// package-lock.json is generated by npm install
// playwright.config.ts is the main file where certain settings of the framework can be tweaked


/* Test execution with CLI */
// to run all tests `npm playwright test`
// to see the report of the last execution `npx playwright show-report`
// to run the test on a specific browser use `npx playwright test --project=chromium`
// to see the browser when running the test `npx playwright test --project=chromium --headed`
// to run a specific test file `npm playwright test example.spec.ts`
// to run a specific test in a test file `npm playwright test -g "has title"`
// to run the tests in ui mode `npx playwright test --ui` (super useful for debugging)
// using the trace mode to analyze and debug `npx playwright test --trace on` (this will generate a traces section in report)
// using the playwright debugger `npx playwright test --project=chromium --debug` (this will launch a inspector and a browser)


/* To automate existing chrome session */
// Assuming the user data has been copied to temp dir, this would launch chrome on port 9222 with existing user credentials
PS C:\Users\srivatka> & 'C:\Program Files\Google\Chrome\Application\chrome.exe' --remote-debugging-port=9222 --user-data-dir="C:\temp\chrome-debug"

// Test the connection. Save this to a .js file and run the test to see if it works as intended
import { test, expect, chromium } from '@playwright/test';

test('Run test in already opened browser', async() =>{
    const browser = await chromium.connectOverCDP('http://127.0.0.1:9222');
    const defaultContext = browser.contexts()[0];
    const page = defaultContext.pages()[0];

    await page.goto('https://www.google.com/search?q=playwright+by+testers+talk');
    await page.getByRole('link', { name: 'Playwright by Testers Talk' }).first().click();
});


/* Tests structure */
test('body', () => { // test accepts two parameter: name of the test and the actual test method (Note: A file can have many tests)

})

test.describe('description', () => { // to group multiple tests
  test('body_1', () => {

  })
  test('body_2', () => {

  })
  test('body_3', () => {

  })
})

// In order to run a test, a page has to be created
test('body', ({page}) => { // Page provides methods to interact with a single tab in a Browser

})

// The goto method
test('body', async ({page}) => { // async is used to denote this is a asynchronous function (Note: await can only be used in a asynchronous function)
  await page.goto("localhost:8090"); // await is used when a method returns a promise
  await page.getByText("forms").click();
})
//NOTE: All available methods for page can be found here: https://playwright.dev/docs/api/class-page


// Hooks and flow control
test.beforeEach(async ({page}) => { // runs before each test in a file
  await page.goto("localhost:8090");
})
//NOTE: All available methods for test can be found here: https://playwright.dev/docs/api/class-test


/* Locator Syntax Rules (Locators represent a way to find element(s) on the page at any moment. A locator can be created with the page.locator() method) */
// Quick Note (before getting started)

// What is a Locator?
// A Locator is an object that represents a "recipe" for finding elements in the DOM
// It's lazy - doesn't search until you perform an action

/* Key Points */
// page.locator() returns a Locator object
const button = page.locator('#submit');  // Returns Locator

// Locator also has .locator() method (for scoping/nesting)
page.locator('.sidebar').locator('button');  // Both return Locators

// Locators are chainable
await page
  .locator('.container')   // Returns Locator
  .locator('.item')        // Returns Locator
  .locator('button')       // Returns Locator
  .click();                // Action method

// Remember
// Both Page and Locator have `.locator()` method**
// Both return a Locator object**
// Use `locator.locator()` to narrow down searches (find within)

// locate by tag name
page.locator('input') // finds all input tags in a document

// locate by ID
page.locator('#inputEmail')

// locate by class value
page.locator('.shape-rectangle')

// locate by attributes
page.locator('[placeholder="Email"]')

// locate by entire class value
page.locator('[class="input-full-width size-medium status-basic shape-rectangle nb-transition"]')

// locate by combining different selectors (eg: to find by tag and attribute)
page.locator('input[placeholder="Email"]'

// locate a child element by combining different selectors
page.locator('nb-card').locator('nb-radio').locator(':test-is("Option 2")').click()
//[ALTERNATIVE]
page.locator('nb-card nb-radio :test-is("Option 2")').click()

// locate a parent element (here playwright gives only nb-card that has the text "Using the grid")
page.locator('nb-card', {hasText: "Using the grid"})
//[ALTERNATIVE]
page.locator('nb-card').filter({hasText: "Using the grid"})

// locate by partial text match
page.locator(':text("some_text")')

// locate by exact text match
page.locator(':text-is("some_text")')


/* User-Facing Locators (Flakiness is the silent killer of test confidence. A test suite that passes one moment and fails the next destroys trust.) */
page.getByRole('textbox', {name: "Email"}) // Allows locating elements by their ARIA role, ARIA attributes and accessible name (screen readers and other assistive technologies use these roles to understand the page)
// Example code
test('accessible button selection', async ({ page }) => {
  // Find a button by its accessible name
  await page.getByRole('button', { name: 'Login' }).click();

  // Find a heading of a specific level
  const mainHeading = page.getByRole('heading', { level: 1 });
  await expect(mainHeading).toHaveText('Welcome to our App');

  // Find a checkbox
  await page.getByRole('checkbox', { name: 'I agree to the terms' }).check();
});

// NOTE: See the accessibility tab on devtools to see what roles are available

// The power of role-based selection extends beyond simple elements. Complex widgets like tabs, menus, and dialogs all have specific ARIA roles that make them easily targetable
// Example Code
test('complex widget interaction', async ({ page }) => {
  // Navigate tabs
  await page.getByRole('tab', { name: 'Settings' }).click();

  // Interact with menu items
  await page.getByRole('button', { name: 'File' }).click();
  await page.getByRole('menuitem', { name: 'Save As...' }).click();

  // Handle dialogs
  const dialog = page.getByRole('dialog', { name: 'Save Document' });
  await dialog.getByRole('textbox', { name: 'Filename' }).fill('report.pdf');
  await dialog.getByRole('button', { name: 'Save' }).click();
});
/*

// NOTE: The code example is about custom web dialogs (HTML/ARIA), NOT the native OS file picker!

Native OS file pickers are NOT automatable with regular Playwright locators:

User clicks "Save As..." 
   → Native Windows/Mac/Linux file manager opens
   → This is OUTSIDE the browser DOM
   → getByRole() CANNOT see it

What You CAN Do with Playwright

File Uploads

// Don't interact with file picker - directly set the file
await page.locator('input[type="file"]').setInputFiles('path/to/file.pdf');

// Or use getByLabel
await page.getByLabel('Upload file').setInputFiles('document.pdf');

File Downloads

// Listen for download event
const downloadPromise = page.waitForEvent('download');
await page.getByRole('button', { name: 'Download' }).click();
const download = await downloadPromise;

// Save to specific path
await download.saveAs('/path/to/save/file.pdf');

*/

// getByText and getByLabel are your next best options when role-based selection isn't suitable
// These locators excel when dealing with content that users read directly or form fields with proper label associations
// Example Code
test('text and label selection', async ({ page }) => {
  // Select by visible text (great for static content)
  await expect(page.getByText('Your order has been confirmed'))
    .toBeVisible();

  // Partial text matching with regex
  await page.getByText(/Welcome back, \w+/).click();

  // Form inputs via label association
  await page.getByLabel('Email Address').fill('user @ example.com');

  // Exact vs substring matching
  await page.getByText('Login', { exact: true }).click(); // Won't match "Login!"
});

// NOTE: All available methods for locators can be found here: https://playwright.dev/docs/api/class-locator


/* Reusing Locators */
// To avoid duplication, variables and constants can be used
// Example Code
test('Reusing the Locators', async ({page}) => {
  const basicForm = page.locator('nb-card').filter({hasText: "Basic Form"})

  await basicForm.getByRole('textbox', {name: "Email"}).fill('test@test.com')
  await basicForm.getByRole('textbox', {name: "Password"}).fill('welcome123')
  await basicForm.getByRole('button').click()
})

test('extracting values', async ({page}) => {
  // single text value
  const basicForm = page.locator('nb-card').filter({hasText: "Basic Form"})
  const buttonText = await basicForm.locator('button').textContent();
  expect(buttonText).toEqual('Submit')

  // all text values
  const allRadioButtonsLabels = await page.locator('nb-radio').allTextContents()
  expect(allRadioButtonsLabels).toContain("Option 1")

  // input value
  const emailField = basicForm.getByRole('textbox', {name: "Email"})
  await emailField.fill('test@test.com')
  const emailValue = await emailField.inputValue()
  expect(emailValue).toEqual('test@test.com')
  const placeholderValue = await emailField.getAttribute('placeholder')
  expect(buttonText).toEqual('Email')
})
